<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Something Feels Wrong</title>
<link href="https://fonts.googleapis.com/css2?family=Rubik+Glitch&display=swap" rel="stylesheet">
  <style>
body {
      background-color: #000;
      color: #eee;
  font-family: 'Rubik Glitch', sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 2rem;
      text-align: center;
    }

    /* CHANGED: Code-green + glow for the header */
    h1.glitch {
       color: #4caf50; /* darker, muted green */
  text-shadow: 
    0 0 2px #2e7d32,  /* subtle deep green shadow */
    0 0 5px #1b5e20, 
    0 0 8px #111;     /* soft black edge to keep readable */
      position: relative;
      display: inline-block;
      margin: 0.5rem 0 1rem;
      letter-spacing: 1px;
    }

    p {
      max-width: 700px;
      margin: 1rem auto;
       font-family: "Courier New", monospace; 
       color: #cde; 
  text-shadow: 0 0 2px #00994d;
    }

  @media (max-width: 600px) {
    h1.glitch {
      text-shadow: 0 0 1px #00ff66, 0 0 3px #00ff66; /* even softer on phones */
    }
  } /* âœ…

    /* Top-only static/flicker layer stays GLOBAL so it applies everywhere */
  .glitch::before {
    content: attr(data-text);
    position: absolute;
    left: 0; top: 0;
    width: 100%; height: 40%;
    color: #8affb2;
    text-shadow: 0 0 3px #8affb2, 0 0 8px #8affb2;
    overflow: hidden;
    pointer-events: none;
    animation: staticy 0.35s infinite steps(2, end);
    mix-blend-mode: screen;
  }
  @keyframes staticy {
    0%   { clip-path: inset(0 0 72% 0); transform: translate(1px, -1px); }
    20%  { clip-path: inset(0 0 58% 0); transform: translate(-1px, 1px); }
    40%  { clip-path: inset(0 0 65% 0); transform: translate(2px, 0); }
    60%  { clip-path: inset(0 0 60% 0); transform: translate(-2px, -1px); }
    80%  { clip-path: inset(0 0 70% 0); transform: translate(0, 1px); }
    100% { clip-path: inset(0 0 62% 0); transform: translate(1px, 0); }
  }
#hotspot {
  position: fixed;
  top: 0;
  right: 0;
  width: 90px;             /* keep it small */
  height: 90px;
  cursor: pointer;
  z-index: 9999;

  /* ray look */
  background: radial-gradient(
    circle at top right,
    rgba(255,255,210,0.75) 0%,
    rgba(255,250,180,0.45) 30%,
    rgba(255,240,150,0.12) 60%,
    transparent 100%
  );
  transform-origin: top right;
  transform: rotate(-25deg) scaleY(1.1);
  mix-blend-mode: screen;

  /* âš¡ step-wise flicker: hard cuts, no tweening */
  animation: flickerRay 7s steps(1, end) infinite;
}

/* Hard cut to dark, hold, then snap back to bright */
@keyframes flickerRay {
  /* bright intro & brief pre-flicker flutter */
  0%, 2%   { opacity: 1;   filter: brightness(1.05); }
  3%       { opacity: 0.7; filter: brightness(0.9); }   /* tiny hiccup */
  4%       { opacity: 1;   filter: brightness(1.1); }   /* back to bright */

  /* ðŸ”» instant blackout, then hold it */
  5%, 72%  { opacity: 0.08; filter: brightness(0.28); }

  /* ðŸ”º instant return to full brightness, then hold */
  73%,100% { opacity: 1;   filter: brightness(1.1); }
}



 .pop-12 {
    position: fixed;
    font-family: "Courier New", monospace;
    font-weight: 700;
    color: #12ff85;
    text-shadow: 0 0 4px #12ff85, 0 0 8px rgba(18,255,133,0.6);
    pointer-events: none;
    z-index: 10000;
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.85);
    animation: float12 900ms ease-out forwards;
  }

  @keyframes float12 {
    0%   { opacity: 0; transform: translate(-50%, -50%) translateY(8px) scale(0.85); }
    10%  { opacity: 1; }
    70%  { opacity: 1; transform: translate(-50%, -50%) translateY(-28px) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -50%) translateY(-44px) scale(1.06); }
  }

  @media (prefers-reduced-motion: reduce) {
    .pop-12 { animation-duration: 200ms; }
  }
  </style>
</head>


<body>
    <div id="hotspot" aria-label="secret"></div>

  <h1 class="glitch" data-text="WHAT'S WRONG">WHAT'S WRONG</h1>
  <p>
    Have you felt it? We tell ourselves itâ€™s just stress, just growing up, just the price of ambition. <br> But in the deepest part of us, we know. We know <br> SOMETHING ABOUT THIS CAMPUS IS OFF <br>
The dread you feel is no accident. It is the first signal. The sense that the life you are living has been carefully constructed, not by you, but by something that feeds on your exhaustion. You are right to feel uneasy. You are right to wonder if your reflection is still yours. <br> DO YOU FEEL OFF<br>
Is everyone else just playing pretend or are they distracted? Thereâ€™s no way it can be true what they believe. But sometimes I catch it.The flicker at the corner of vision. The slight delay in the loop. The hairline crack in the world where the pattern slips. And when it does, I know with certainty:
this isnâ€™t life.<br>
Itâ€™s a performance. <br>
And something else is watching.<br>

  </p>
  <p><em>[ FAIL TO REVEAL THE TRUTH ]</em></p>
  <!-- === PONG: sticky footer game === -->
<section id="pong-footer" style="
  position: sticky;
  bottom: 0;
  width: 100%;
  background:#000;
  border-top:1px solid #333;
  padding: 20px 0 18px;
  display:flex;
  flex-direction:column;
  align-items:center;
  z-index: 2;">
  
<canvas id="pong" style="display:block;max-width:100%; touch-action: none;"></canvas>
</section>

<script>
(() => {
  const canvas = document.getElementById('pong');
  const footer = document.getElementById('pong-footer');
  const ctx = canvas.getContext('2d');

  // ===== CONFIG =====
  const PLAYER_WIN_POINTS = 2;     // your per-match winning score
  const AI_WIN_POINTS = 100;         // AI per-match winning score

  const GLITCH_TRIGGER_POINTS = 6; // cumulative AI points across all rounds to trigger glitch
  const GLITCH_CLEAR_ON_SCORE = true; // if true, your next point clears the glitch

  const AI_MATCH_SKIP = 2;         // when AI match wins would equal this number...
  const AI_MATCH_SKIP_TO = 4;      // ...jump straight to this number instead

  // ===== SIZING =====
  function resize() {
    const maxW = Math.min(footer ? footer.clientWidth - 24 : window.innerWidth - 24, 900);
    canvas.width  = Math.max(480, maxW);
    canvas.height = Math.round(canvas.width * 0.45);
  }
  resize();
  window.addEventListener('resize', resize);

  // Ensure touch doesn't scroll the page while playing
  canvas.style.touchAction = 'none';

  // ===== STATE =====
  const state = {
    paused: false,
    scoreL: 0,   // you
    scoreR: 0,   // ai
    keys: { up:false, down:false, w:false, s:false },
    gameOver: false,
    winner: null,

    // Meta
    aiPointTotal: 0,   // cumulative AI points across all rounds
    aiMatchWins: 0,    // number of matches AI has won
    glitchActive: false
  };

  function dims() {
    const PAD_W = Math.max(6, Math.round(canvas.width * 0.012));
    const PAD_H = Math.max(40, Math.round(canvas.height * 0.3));
    const BALL  = Math.max(6, Math.round(canvas.width * 0.012));
    const SPEED = canvas.height * 0.75;
    return { PAD_W, PAD_H, BALL, SPEED };
  }

  const player = { x: 0, y: 0, vy: 0 };
  const ai     = { x: 0, y: 0, vy: 0 };
  const ball   = { x: 0, y: 0, vx: 0, vy: 0, speed: 0 };

  function resetPositions(servingLeft = Math.random() < 0.5) {
    const { PAD_W, PAD_H } = dims();
    player.x = 16;
    player.y = (canvas.height - PAD_H) / 2;
    ai.x = canvas.width - PAD_W - 16;
    ai.y = (canvas.height - PAD_H) / 2;

    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
    const angle = (Math.random() * 0.6 - 0.3);
    const dir = servingLeft ? -1 : 1;
    const base = dims().SPEED * 0.85;
    ball.speed = base;
    ball.vx = Math.cos(angle) * ball.speed * dir;
    ball.vy = Math.sin(angle) * ball.speed;
  }
  resetPositions();

  // ===== INPUT =====
  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowUp') state.keys.up = true;
    if (e.code === 'ArrowDown') state.keys.down = true;
    if (e.key === 'w' || e.key === 'W') state.keys.w = true;
    if (e.key === 's' || e.key === 'S') state.keys.s = true;
    if (e.code === 'Space' && !state.gameOver) state.paused = !state.paused;
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowUp') state.keys.up = false;
    if (e.code === 'ArrowDown') state.keys.down = false;
    if (e.key === 'w' || e.key === 'W') state.keys.w = false;
    if (e.key === 's' || e.key === 'S') state.keys.s = false;
  });

  // Touch (drag anywhere on canvas to move your paddle)
  let touchY = null, touching = false;
  function toCanvasY(clientY) {
    const r = canvas.getBoundingClientRect();
    return (clientY - r.top) * (canvas.height / r.height);
  }
  function onTouch(e) {
    if (e.touches && e.touches[0]) {
      e.preventDefault();
      touching = true;
      touchY = toCanvasY(e.touches[0].clientY);
    }
  }
  function onTouchEnd() { touching = false; touchY = null; }
  canvas.addEventListener('touchstart', onTouch, { passive:false });
  canvas.addEventListener('touchmove', onTouch, { passive:false });
  canvas.addEventListener('touchend', onTouchEnd, { passive:true });
  canvas.addEventListener('touchcancel', onTouchEnd, { passive:true });

  // ===== LOOP =====
  let last = performance.now();
  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    if (!state.paused && !state.gameOver) update(dt);
    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  // ===== UPDATE =====
  function update(dt){
    const { PAD_W, PAD_H, BALL, SPEED } = dims();

    // Player movement (touch or keyboard)
    const maxVy = SPEED * 0.95;
    if (touching && touchY != null) {
      const targetY = Math.max(0, Math.min(canvas.height - PAD_H, touchY - PAD_H/2));
      const diff = targetY - player.y;
      player.vy = Math.max(-maxVy, Math.min(maxVy, diff * 12));
    } else {
      let target = 0;
      if (state.keys.up || state.keys.w) target = -maxVy;
      if (state.keys.down || state.keys.s) target =  maxVy;
      player.vy += (target - player.vy) * Math.min(1, dt * 12);
    }
    player.y += player.vy * dt;
    player.y = Math.max(0, Math.min(canvas.height - PAD_H, player.y));

    // AI movement (freeze if glitch)
    if (!state.glitchActive) {
      const aiCenter = ai.y + PAD_H/2;
      const targetY = ball.y + ball.vy * 0.12;
      const aiSpeed = SPEED * 0.75;
      if (aiCenter < targetY - 6) ai.vy = aiSpeed;
      else if (aiCenter > targetY + 6) ai.vy = -aiSpeed;
      else ai.vy = 0;
      ai.y += ai.vy * dt;
      ai.y = Math.max(0, Math.min(canvas.height - PAD_H, ai.y));
    } else {
      ai.vy = 0; // "stops working"
    }

    // Ball physics
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    if (ball.y <= 0 && ball.vy < 0) { ball.y = 0; ball.vy *= -1; }
    if (ball.y >= canvas.height - BALL && ball.vy > 0) {
      ball.y = canvas.height - BALL; ball.vy *= -1;
    }

    // Paddle collisions
    if (ball.x <= player.x + PAD_W && ball.x >= player.x - BALL) {
      if (ball.y + BALL >= player.y && ball.y <= player.y + PAD_H) {
        ball.x = player.x + PAD_W;
        const hitPos = ((ball.y + BALL/2) - (player.y + PAD_H/2)) / (PAD_H/2);
        const ang = hitPos * 0.6;
        ball.speed = Math.min(ball.speed * 1.05, SPEED * 1.8);
        const sp = ball.speed;
        ball.vx = Math.abs(Math.cos(ang) * sp);
        ball.vy = Math.sin(ang) * sp;
      }
    }
    if (ball.x + BALL >= ai.x && ball.x <= ai.x + PAD_W) {
      if (ball.y + BALL >= ai.y && ball.y <= ai.y + PAD_H) {
        ball.x = ai.x - BALL;
        const hitPos = ((ball.y + BALL/2) - (ai.y + PAD_H/2)) / (PAD_H/2);
        const ang = hitPos * 0.6;
        ball.speed = Math.min(ball.speed * 1.05, SPEED * 1.8);
        const sp = ball.speed;
        ball.vx = -Math.abs(Math.cos(ang) * sp);
        ball.vy = Math.sin(ang) * sp;
      }
    }

    // Scoring
    const outLeft = ball.x < -BALL;
    const outRight = ball.x > canvas.width + BALL;
    if (outLeft || outRight) {
      if (outLeft) {
        state.scoreR++;
        state.aiPointTotal++;


  // ðŸ‘‡ put the skip logic right here
  if (state.scoreR === AI_MATCH_SKIP) {
    state.scoreR = AI_MATCH_SKIP_TO;
  }

        // Trigger glitch at configured cumulative AI points
        if (!state.glitchActive && state.aiPointTotal === GLITCH_TRIGGER_POINTS) {
          state.glitchActive = true;
        }
      } else if (outRight) {
        state.scoreL++;

        // Clear glitch if configured
        if (state.glitchActive && GLITCH_CLEAR_ON_SCORE) {
          state.glitchActive = false;
        }
      }

      // End-of-match checks
      if (state.scoreL >= PLAYER_WIN_POINTS) {
        state.gameOver = true;
        state.winner = "player";
      } else if (state.scoreR >= AI_WIN_POINTS) {
        state.gameOver = true;
        state.winner = "ai";

      
      } else {
        resetPositions(outRight); // serve toward conceding side
      }
    }
  }

  // ===== DRAW =====
  function draw(){
    const { PAD_W, PAD_H, BALL } = dims();

    // Field
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Midline
    ctx.strokeStyle = '#222';
    ctx.setLineDash([8,10]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width/2, 0);
    ctx.lineTo(canvas.width/2, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);

    // Paddles & ball
    ctx.fillStyle = '#e6e6e6';
    ctx.fillRect(player.x, player.y, PAD_W, PAD_H);
    ctx.fillRect(ai.x, ai.y, PAD_W, PAD_H);
    ctx.fillRect(ball.x, ball.y, BALL, BALL);

    // Score
    ctx.fillStyle = '#bbb';
    ctx.font = `bold ${Math.round(canvas.height*0.18)}px Courier New, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(state.scoreL, canvas.width*0.25, 8);
    ctx.fillText(state.scoreR, canvas.width*0.75, 8);

    // Glitch overlay
    if (state.glitchActive) {
      ctx.fillStyle = 'rgba(255,0,0,0.08)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#f55';
      ctx.font = `bold ${Math.round(canvas.height*0.10)}px Courier New, monospace`;
      ctx.textBaseline = 'middle';
      ctx.fillText('SYSTEM ERROR', canvas.width/2, canvas.height*0.35);

      ctx.font = `bold ${Math.round(canvas.height*0.06)}px Courier New, monospace`;
      ctx.fillStyle = '#faa';
      ctx.fillText('AI MODULE OFFLINE', canvas.width/2, canvas.height*0.50);

      ctx.font = `bold ${Math.round(canvas.height*0.045)}px Courier New, monospace`;
      ctx.fillStyle = '#fcc';
      ctx.fillText('Score a point to restore control', canvas.width/2, canvas.height*0.64);
    }

    // Game Over
    if (state.gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = state.winner === "player" ? '#0f0' : '#f00';
      ctx.font = `bold ${Math.round(canvas.height*0.14)}px Courier New, monospace`;
      ctx.textBaseline = 'middle';
      ctx.fillText(state.winner === "player" ? "YOU WIN" : "YOU LOSE", canvas.width/2, canvas.height/2);

      // (Optional debug readout â€“ remove if you want)
      ctx.fillStyle = '#bbb';
      ctx.font = `bold ${Math.round(canvas.height*0.04)}px Courier New, monospace`;
      ctx.textBaseline = 'top';
      ctx.fillText(`AI match wins: ${state.aiMatchWins}`, canvas.width/2, canvas.height*0.72);
    }

    // Pause
    if (state.paused && !state.gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#f33';
      ctx.font = `bold ${Math.round(canvas.height*0.12)}px Courier New, monospace`;
      ctx.textBaseline = 'middle';
      ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
    }
  }
})();
</script>


<!-- === /PONG === -->

  <script>
(() => {
  const spot = document.getElementById('hotspot');
  let timer = null;

  function spawn12(){
    const rect = spot.getBoundingClientRect();
    const el = document.createElement('div');
    el.className = 'pop-12';
    el.textContent = '12';
    const jitterX = (Math.random()*24) - 12;
    const jitterY = (Math.random()*10) - 5;
    const x = rect.left + rect.width/2 + jitterX;
    const y = rect.top  + rect.height/2 + jitterY;
    el.style.left = x + 'px';
    el.style.top  = y + 'px';
    document.body.appendChild(el);
    el.addEventListener('animationend', () => el.remove());
  }

  function start(){ if (timer) return; spawn12(); timer = setInterval(spawn12, 140); }
  function stop(){ clearInterval(timer); timer = null; }

  // Mouse
  spot.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); start(); });
  window.addEventListener('mouseup', stop);

  // Touch
  spot.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); start(); }, { passive:false });
  window.addEventListener('touchend', stop, { passive:true });
  window.addEventListener('touchcancel', stop, { passive:true });
})();
</script>
</body>
</html>
