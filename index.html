<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Something Feels Wrong</title>
<link href="https://fonts.googleapis.com/css2?family=Rubik+Glitch&display=swap" rel="stylesheet">
  <style>
body {
      background-color: #000;
      color: #eee;
  font-family: 'Rubik Glitch', sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 2rem;
      text-align: center;
    }

    /* CHANGED: Code-green + glow for the header */
    h1.glitch {
       color: #4caf50; /* darker, muted green */
  text-shadow: 
    0 0 2px #2e7d32,  /* subtle deep green shadow */
    0 0 5px #1b5e20, 
    0 0 8px #111;     /* soft black edge to keep readable */
      position: relative;
      display: inline-block;
      margin: 0.5rem 0 1rem;
      letter-spacing: 1px;
    }

    p {
      max-width: 700px;
      margin: 1rem auto;
       font-family: "Courier New", monospace; 
       color: #cde; 
  text-shadow: 0 0 2px #00994d;
    }
    @media (max-width: 600px) {
  h1.glitch {
    text-shadow: 0 0 1px #00ff66, 0 0 3px #00ff66; /* even softer on phones */
  }

    /* CHANGED: Top-only static/flicker layer */
    .glitch::before {
      content: attr(data-text);
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 40%;              /* only affect the top portion */
      color: #8affb2;           /* slightly different green for eerie contrast */
      text-shadow: 0 0 3px #8affb2, 0 0 8px #8affb2;
      overflow: hidden;
      pointer-events: none;
      animation: staticy 0.35s infinite steps(2, end);
      mix-blend-mode: screen;   /* makes the overlay feel more 'video-ish' */
    }

    /* CHANGED: Remove old ::after glitch & keyframes; new static animation */
    @keyframes staticy {
      0%   { clip-path: inset(0 0 72% 0); transform: translate(1px, -1px); }
      20%  { clip-path: inset(0 0 58% 0); transform: translate(-1px, 1px); }
      40%  { clip-path: inset(0 0 65% 0); transform: translate(2px, 0); }
      60%  { clip-path: inset(0 0 60% 0); transform: translate(-2px, -1px); }
      80%  { clip-path: inset(0 0 70% 0); transform: translate(0, 1px); }
      100% { clip-path: inset(0 0 62% 0); transform: translate(1px, 0); }
    }
  </style>
</head>
<body>
  <h1 class="glitch" data-text="WHAT'S WRONG">WHAT'S WRONG</h1>
  <p>
    Have you felt it? We tell ourselves it’s just stress, just growing up, just the price of ambition. <br> But in the deepest part of us, we know. We know <br> SOMETHING ABOUT THIS CAMPUS IS OFF <br>
The dread you feel is no accident. It is the first signal. The sense that the life you are living has been carefully constructed, not by you, but by something that feeds on your exhaustion. You are right to feel uneasy. You are right to wonder if your reflection is still yours. <br> DO YOU FEEL OFF<br>
Is everyone else just playing pretend or are they distracted? There’s no way it can be true what they believe. But sometimes I catch it.The flicker at the corner of vision. The slight delay in the loop. The hairline crack in the world where the pattern slips. And when it does, I know with certainty:
this isn’t life.<br>
It’s a performance. <br>
And something else is watching.<br>

  </p>
  <p><em>[ END OF TRANSMISSION ]</em></p>
  <!-- === PONG: sticky footer game === -->
<section id="pong-footer" style="
  position: sticky;
  bottom: 0;
  width: 100%;
  background:#000;
  border-top:1px solid #333;
  padding: 20px 0 18px;
  display:flex;
  flex-direction:column;
  align-items:center;
  z-index: 2;">
  
<canvas id="pong" style="display:block;max-width:100%; touch-action: none;"></canvas>
</section>

<script>
(() => {
  const canvas = document.getElementById('pong');
  const footer = document.getElementById('pong-footer');
  const ctx = canvas.getContext('2d');

  function resize() {
    const maxW = Math.min(footer.clientWidth - 24, 900);
    canvas.width  = Math.max(480, maxW);
    canvas.height = Math.round(canvas.width * 0.45);
  }
  resize();
  window.addEventListener('resize', resize);

  const state = {
    paused: false,
    scoreL: 0,
    scoreR: 0,
    keys: { up:false, down:false, w:false, s:false },
    gameOver: false,
    winner: null,
    touching: false,
    touchY: null
  };

  function dims() {
    const PAD_W = Math.max(6, Math.round(canvas.width * 0.012));
    const PAD_H = Math.max(40, Math.round(canvas.height * 0.3));
    const BALL  = Math.max(6, Math.round(canvas.width * 0.012));
    const SPEED = canvas.height * 0.75;
    return { PAD_W, PAD_H, BALL, SPEED };
  }

  const player = { x: 0, y: 0, vy: 0 };
  const ai      = { x: 0, y: 0, vy: 0 };
  const ball    = { x: 0, y: 0, vx: 0, vy: 0, speed: 0 };

  function resetPositions(servingLeft = Math.random() < 0.5) {
    const { PAD_W, PAD_H } = dims();
    player.x = 16;
    player.y = (canvas.height - PAD_H) / 2;
    ai.x = canvas.width - PAD_W - 16;
    ai.y = (canvas.height - PAD_H) / 2;

    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
    const angle = (Math.random() * 0.6 - 0.3);
    const dir = servingLeft ? -1 : 1;
    const base = dims().SPEED * 0.85;
    ball.speed = base;
    ball.vx = Math.cos(angle) * ball.speed * dir;
    ball.vy = Math.sin(angle) * ball.speed;
  }
  resetPositions();

  // Keyboard input
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowUp') state.keys.up = true;
    if (e.code === 'ArrowDown') state.keys.down = true;
    if (e.key === 'w' || e.key === 'W') state.keys.w = true;
    if (e.key === 's' || e.key === 'S') state.keys.s = true;
    if (e.code === 'Space' && !state.gameOver) state.paused = !state.paused;
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowUp') state.keys.up = false;
    if (e.code === 'ArrowDown') state.keys.down = false;
    if (e.key === 'w' || e.key === 'W') state.keys.w = false;
    if (e.key === 's' || e.key === 'S') state.keys.s = false;
  });

  // Touch input (drag to move paddle)
  function toCanvasY(clientY) {
    const r = canvas.getBoundingClientRect();
    return (clientY - r.top) * (canvas.height / r.height);
  }
  function onTouch(e) {
    if (e.touches && e.touches[0]) {
      e.preventDefault(); // stop page scroll
      state.touching = true;
      state.touchY = toCanvasY(e.touches[0].clientY);
    }
  }
  function onTouchEnd() {
    state.touching = false;
    state.touchY = null;
  }
  canvas.addEventListener('touchstart', onTouch, { passive: false });
  canvas.addEventListener('touchmove', onTouch, { passive: false });
  canvas.addEventListener('touchend', onTouchEnd, { passive: false });
  canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

  let last = performance.now();
  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    if (!state.paused && !state.gameOver) update(dt);
    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function update(dt){
    const { PAD_W, PAD_H, BALL, SPEED } = dims();

    // Player movement: keyboard or touch
    const maxVy = SPEED * 0.95;

    if (state.touching && state.touchY != null) {
      // Smoothly move paddle center toward touchY
      const targetY = state.touchY - PAD_H / 2;
      const clampY = Math.max(0, Math.min(canvas.height - PAD_H, targetY));
      const diff = clampY - player.y;
      player.vy = diff * 12; // follow factor
      // Limit velocity so it feels fair
      if (player.vy > maxVy) player.vy = maxVy;
      if (player.vy < -maxVy) player.vy = -maxVy;
    } else {
      // Keyboard fallback
      let target = 0;
      if (state.keys.up || state.keys.w) target = -maxVy;
      if (state.keys.down || state.keys.s) target =  maxVy;
      player.vy += (target - player.vy) * Math.min(1, dt * 12);
    }

    player.y += player.vy * dt;
    player.y = Math.max(0, Math.min(canvas.height - PAD_H, player.y));

    // AI movement
    const aiCenter = ai.y + PAD_H/2;
    const targetY = ball.y + ball.vy * 0.12;
    const aiSpeed = SPEED * 0.75;
    if (aiCenter < targetY - 6) ai.vy = aiSpeed;
    else if (aiCenter > targetY + 6) ai.vy = -aiSpeed;
    else ai.vy = 0;
    ai.y += ai.vy * dt;
    ai.y = Math.max(0, Math.min(canvas.height - PAD_H, ai.y));

    // Ball physics
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    if (ball.y <= 0 && ball.vy < 0) { ball.y = 0; ball.vy *= -1; }
    if (ball.y >= canvas.height - BALL && ball.vy > 0) {
      ball.y = canvas.height - BALL; ball.vy *= -1;
    }

    // Collisions
    if (ball.x <= player.x + PAD_W && ball.x >= player.x - BALL) {
      if (ball.y + BALL >= player.y && ball.y <= player.y + PAD_H) {
        ball.x = player.x + PAD_W;
        const hitPos = ((ball.y + BALL/2) - (player.y + PAD_H/2)) / (PAD_H/2);
        const ang = hitPos * 0.6;
        ball.speed = Math.min(ball.speed * 1.05, SPEED * 1.8);
        const sp = ball.speed;
        ball.vx = Math.abs(Math.cos(ang) * sp);
        ball.vy = Math.sin(ang) * sp;
      }
    }
    if (ball.x + BALL >= ai.x && ball.x <= ai.x + PAD_W) {
      if (ball.y + BALL >= ai.y && ball.y <= ai.y + PAD_H) {
        ball.x = ai.x - BALL;
        const hitPos = ((ball.y + BALL/2) - (ai.y + PAD_H/2)) / (PAD_H/2);
        const ang = hitPos * 0.6;
        ball.speed = Math.min(ball.speed * 1.05, SPEED * 1.8);
        const sp = ball.speed;
        ball.vx = -Math.abs(Math.cos(ang) * sp);
        ball.vy = Math.sin(ang) * sp;
      }
    }

    // Scoring + end conditions (13 for you, 21 for AI)
    const outLeft = ball.x < -BALL;
    const outRight = ball.x > canvas.width + BALL;
    if (outLeft || outRight) {
      if (outLeft) state.scoreR++;
      if (outRight) state.scoreL++;

      if (state.scoreL >= 13) {
        state.gameOver = true;
        state.winner = "player";
      } else if (state.scoreR >= 21) {
        state.gameOver = true;
        state.winner = "ai";
      } else {
        resetPositions(outRight);
      }
    }
  }

  function draw(){
    const { PAD_W, PAD_H, BALL } = dims();
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Midline
    ctx.strokeStyle = '#222';
    ctx.setLineDash([8,10]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width/2, 0);
    ctx.lineTo(canvas.width/2, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);

    // Objects
    ctx.fillStyle = '#e6e6e6';
    ctx.fillRect(player.x, player.y, PAD_W, PAD_H);
    ctx.fillRect(ai.x, ai.y, PAD_W, PAD_H);
    ctx.fillRect(ball.x, ball.y, BALL, BALL);

    // Score
    ctx.fillStyle = '#bbb';
    ctx.font = `bold ${Math.round(canvas.height*0.18)}px Courier New, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(state.scoreL, canvas.width*0.25, 8);
    ctx.fillText(state.scoreR, canvas.width*0.75, 8);

    // Game over overlay
    if (state.gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = state.winner === "player" ? '#0f0' : '#f00';
      ctx.font = `bold ${Math.round(canvas.height*0.14)}px Courier New, monospace`;
      ctx.textBaseline = 'middle';
      ctx.fillText(state.winner === "player" ? "YOU WIN" : "YOU LOSE", canvas.width/2, canvas.height/2);
    }

    // Pause overlay
    if (state.paused && !state.gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#f33';
      ctx.font = `bold ${Math.round(canvas.height*0.12)}px Courier New, monospace`;
      ctx.textBaseline = 'middle';
      ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
    }
  }
})();
</script>

<!-- === /PONG === -->
</body>
</html>
