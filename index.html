<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Something Feels Wrong</title>
  <link href="https://fonts.googleapis.com/css2?family=Nosifer&display=swap" rel="stylesheet">
  <style>
    body {
      background-color: #000;
      color: #eee;
font-family: 'Creepster', cursive;
      line-height: 1.6;
      margin: 0;
      padding: 2rem;
      text-align: center;
    }

    h1 {
      color: #008000;
      text-shadow: 0 0 5px #ff0000;
    }

    p {
      max-width: 700px;
      margin: 1rem auto;
    }

    .glitch {
      font-size: 1.5rem;
      color: #008000;
      position: relative;
    }

    .glitch::before,
    .glitch::after {
      content: attr(data-text);
      position: absolute;
      left: 0;
      width: 100%;
      overflow: hidden;
      clip: rect(0, 900px, 0, 0);
    }

    .glitch::before {
      animation: glitchTop 2s infinite linear alternate-reverse;
      color: #0ff;
    }

    .glitch::after {
      animation: glitchBottom 1.5s infinite linear alternate-reverse;
      color: #f0f;
    }

    @keyframes glitchTop {
      0% { clip: rect(0, 9999px, 0, 0); }
      20% { clip: rect(0, 9999px, 50%, 0); transform: translate(-2px, -2px); }
      40% { clip: rect(0, 9999px, 0, 0); }
      60% { clip: rect(0, 9999px, 40%, 0); transform: translate(2px, 2px); }
      80% { clip: rect(0, 9999px, 0, 0); }
      100% { clip: rect(0, 9999px, 60%, 0); transform: translate(-1px, 0); }
    }

    @keyframes glitchBottom {
      0% { clip: rect(0, 9999px, 0, 0); }
      20% { clip: rect(50%, 9999px, 9999px, 0); transform: translate(2px, 0); }
      40% { clip: rect(0, 9999px, 0, 0); }
      60% { clip: rect(40%, 9999px, 9999px, 0); transform: translate(-2px, -1px); }
      80% { clip: rect(0, 9999px, 0, 0); }
      100% { clip: rect(60%, 9999px, 9999px, 0); transform: translate(1px, 1px); }
    }
  </style>
</head>
<body>
  <h1 class="glitch" data-text="SOMETHING IS WRONG">SOMETHING IS WRONG</h1>
  <p>
    Have you felt it? We tell ourselves it’s just stress, just growing up, just the price of ambition. But in the deepest part of us, we know. We know <br> SOMETHING ABOUT THIS CAMPUS IS OFF. <br>
The dread you feel is no accident. It is the first signal. The sense that the life you are living has been carefully constructed, not by you, but by something that feeds on your exhaustion. You are right to feel uneasy. You are right to wonder if your reflection is still yours. <br> DO YOU FEEL OFF<br>
Is everyone else just playing pretend or are they distracted? There’s no way it can be true what they believe. But sometimes I catch it.The flicker at the corner of vision. The slight delay in the loop. The hairline crack in the world where the pattern slips. And when it does, I know with certainty:
this isn’t life.<br>
It’s a performance. <br>
And something else is watching.<br>

  </p>
  <p><em>[ END OF TRANSMISSION ]</em></p>
  <!-- === PONG: sticky footer game === -->
<section id="pong-footer" style="
  position: sticky;
  bottom: 0;
  width: 100%;
  background:#000;
  border-top:1px solid #333;
  padding: 12px 0 18px;
  display:flex;
  flex-direction:column;
  align-items:center;
  z-index: 2;">
  <div style="color:#bbb;font-family:Courier New,monospace;font-size:12px;margin-bottom:6px;letter-spacing:.08em;">
    PONG — W/S or ↑/↓ to move • Space to pause
  </div>
  <canvas id="pong" style="display:block;max-width: 100%;"></canvas>
</section>

<script>
(() => {
  const canvas = document.getElementById('pong');
  const footer = document.getElementById('pong-footer');
  const ctx = canvas.getContext('2d');

  function resize() {
    const maxW = Math.min(footer.clientWidth - 24, 900);
    canvas.width  = Math.max(480, maxW);
    canvas.height = Math.round(canvas.width * 0.45);
  }
  resize();
  window.addEventListener('resize', resize);

  const state = {
    paused: false,
    scoreL: 0,
    scoreR: 0,
    keys: { up:false, down:false, w:false, s:false },
    gameOver: false,
    winner: null
  };

  function dims() {
    const PAD_W = Math.max(6, Math.round(canvas.width * 0.012));
    const PAD_H = Math.max(40, Math.round(canvas.height * 0.3));
    const BALL  = Math.max(6, Math.round(canvas.width * 0.012));
    const SPEED = canvas.height * 0.75;
    return { PAD_W, PAD_H, BALL, SPEED };
  }

  const player = { x: 0, y: 0, vy: 0 };
  const ai      = { x: 0, y: 0, vy: 0 };
  const ball    = { x: 0, y: 0, vx: 0, vy: 0, speed: 0 };

  function resetPositions(servingLeft = Math.random() < 0.5) {
    const { PAD_W, PAD_H } = dims();
    player.x = 16;
    player.y = (canvas.height - PAD_H) / 2;
    ai.x = canvas.width - PAD_W - 16;
    ai.y = (canvas.height - PAD_H) / 2;

    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
    const angle = (Math.random() * 0.6 - 0.3);
    const dir = servingLeft ? -1 : 1;
    const base = dims().SPEED * 0.85;
    ball.speed = base;
    ball.vx = Math.cos(angle) * ball.speed * dir;
    ball.vy = Math.sin(angle) * ball.speed;
  }

  resetPositions();

  // Input
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowUp') state.keys.up = true;
    if (e.code === 'ArrowDown') state.keys.down = true;
    if (e.key === 'w' || e.key === 'W') state.keys.w = true;
    if (e.key === 's' || e.key === 'S') state.keys.s = true;
    if (e.code === 'Space' && !state.gameOver) state.paused = !state.paused;
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowUp') state.keys.up = false;
    if (e.code === 'ArrowDown') state.keys.down = false;
    if (e.key === 'w' || e.key === 'W') state.keys.w = false;
    if (e.key === 's' || e.key === 'S') state.keys.s = false;
  });

  let last = performance.now();
  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    if (!state.paused && !state.gameOver) update(dt);
    draw();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  function update(dt){
    const { PAD_W, PAD_H, BALL, SPEED } = dims();

    // Player movement
    const accel = SPEED * 8;
    const maxVy = SPEED * 0.95;
    let target = 0;
    if (state.keys.up || state.keys.w) target = -maxVy;
    if (state.keys.down || state.keys.s) target =  maxVy;
    player.vy += (target - player.vy) * Math.min(1, dt * 12);
    player.y += player.vy * dt;
    player.y = Math.max(0, Math.min(canvas.height - PAD_H, player.y));

    // AI
    const aiCenter = ai.y + PAD_H/2;
    const targetY = ball.y + ball.vy * 0.12;
    const aiSpeed = SPEED * 0.75;
    if (aiCenter < targetY - 6) ai.vy = aiSpeed;
    else if (aiCenter > targetY + 6) ai.vy = -aiSpeed;
    else ai.vy = 0;
    ai.y += ai.vy * dt;
    ai.y = Math.max(0, Math.min(canvas.height - PAD_H, ai.y));

    // Ball
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    if (ball.y <= 0 && ball.vy < 0) { ball.y = 0; ball.vy *= -1; }
    if (ball.y >= canvas.height - BALL && ball.vy > 0) {
      ball.y = canvas.height - BALL; ball.vy *= -1;
    }

    // Collisions
    if (ball.x <= player.x + PAD_W && ball.x >= player.x - BALL) {
      if (ball.y + BALL >= player.y && ball.y <= player.y + PAD_H) {
        ball.x = player.x + PAD_W;
        const hitPos = ((ball.y + BALL/2) - (player.y + PAD_H/2)) / (PAD_H/2);
        const ang = hitPos * 0.6;
        ball.speed = Math.min(ball.speed * 1.05, SPEED * 1.8);
        const sp = ball.speed;
        ball.vx = Math.abs(Math.cos(ang) * sp);
        ball.vy = Math.sin(ang) * sp;
      }
    }
    if (ball.x + BALL >= ai.x && ball.x <= ai.x + PAD_W) {
      if (ball.y + BALL >= ai.y && ball.y <= ai.y + PAD_H) {
        ball.x = ai.x - BALL;
        const hitPos = ((ball.y + BALL/2) - (ai.y + PAD_H/2)) / (PAD_H/2);
        const ang = hitPos * 0.6;
        ball.speed = Math.min(ball.speed * 1.05, SPEED * 1.8);
        const sp = ball.speed;
        ball.vx = -Math.abs(Math.cos(ang) * sp);
        ball.vy = Math.sin(ang) * sp;
      }
    }

    // Scoring
    const outLeft = ball.x < -BALL;
    const outRight = ball.x > canvas.width + BALL;
    if (outLeft || outRight) {
      if (outLeft) state.scoreR++;
      if (outRight) state.scoreL++;

      // Check for win/loss
      if (state.scoreL >= 13) {
        state.gameOver = true;
        state.winner = "player";
      } else if (state.scoreR >= 21) {
        state.gameOver = true;
        state.winner = "ai";
      } else {
        resetPositions(outRight);
      }
    }
  }

  function draw(){
    const { PAD_W, PAD_H, BALL } = dims();
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Midline
    ctx.strokeStyle = '#222';
    ctx.setLineDash([8,10]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width/2, 0);
    ctx.lineTo(canvas.width/2, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);

    // Objects
    ctx.fillStyle = '#e6e6e6';
    ctx.fillRect(player.x, player.y, PAD_W, PAD_H);
    ctx.fillRect(ai.x, ai.y, PAD_W, PAD_H);
    ctx.fillRect(ball.x, ball.y, BALL, BALL);

    // Score
    ctx.fillStyle = '#bbb';
    ctx.font = `bold ${Math.round(canvas.height*0.18)}px Courier New, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(state.scoreL, canvas.width*0.25, 8);
    ctx.fillText(state.scoreR, canvas.width*0.75, 8);

    // Game over screen
    if (state.gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = state.winner === "player" ? '#0f0' : '#f00';
      ctx.font = `bold ${Math.round(canvas.height*0.14)}px Courier New, monospace`;
      ctx.textBaseline = 'middle';
      ctx.fillText(state.winner === "player" ? "YOU WIN" : "YOU LOSE", canvas.width/2, canvas.height/2);
    }

    // Pause overlay
    if (state.paused && !state.gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#f33';
      ctx.font = `bold ${Math.round(canvas.height*0.12)}px Courier New, monospace`;
      ctx.textBaseline = 'middle';
      ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
    }
  }
})();
</script>

<!-- === /PONG === -->
</body>
</html>
